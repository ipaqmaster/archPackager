#!/bin/bash

# This script expects this variable to be defined.
if [ -z "${gpg_passphrase}" ]
then
  echo "Please pass as secure environment variable: gpg_passphrase for signing."
fi

#  _____                 _
# |  ___|   _ _ __   ___| |_ ___
# | |_ | | | | '_ \ / __| __/ __|
# |  _|| |_| | | | | (__| |_\__ \
# |_|   \__,_|_| |_|\___|\__|___/
#


function verifyThing {
  if [ ! -f "${file}.sig" ]
  then
    echo "No signature: ${file}"
    return 1
  fi

  # While this would help verify large files quicker it catches others.
  # We should just verify them by argument or default.
  #fileTimestamp=$(stat -c %Y "${file}")
  #sigTimestamp=$(stat -c %Y "${file}.sig")
  #difference=$((( ${fileTimestamp} - ${sigTimestamp} )))
  #difference=${difference/-/} # Remove possible negative
  ## Return false if signature timestamp is much older than the file.
  #if [ ${difference} > 3600 ]
  #then
  #  echo "Old signature: ${file} (${difference})"
  # return 1
  #fi

  if gpg --quiet --verify ${file}.sig > /dev/null 2>&1
  then
    echo "Valid signature: ${file}"
    return 0
  else
    echo "Invalid signature: ${file}"
    return 1
  fi
}

# Signs a file and adds it to the repo data
function signThing {
  gpg -b --yes --pinentry-mode loopback \
    --passphrase "${gpg_passphrase}" \
    --output "${file}.sig" \
    --sign "${file}"

  gpgReturnCode=$?
  if [ $? -eq 0 ]
  then
    echo "Signed: ${file}."
    return ${gpgReturnCode}
  else
    echo "Failed to sign: ${file}."
    exit 1
  fi

}

# Make the repo aware of a package file
function repoAddThing {
  if [[  "${file}" =~ ^.*.pkg.*.(zst|xz)$ ]]
  then
    repoLockfileWait
    if repo-add --sign ${REPODIR}/${REPONAME}.db.tar.gz "${file}"
    then
      return $?
    else
      if [ -f "${file}.sig" ]
      then
        echo "repo-add failed for ${file}"
        echo "Removing signature so this package so it can be reprocessed on the next run."
        rm -v "${file}.sig"
        exit 1
      fi
    fi
  fi
}


# If a repo has a lockfile, check if the pid inside is valid.
# If so, wait for that PID to exit, otherwise remove it and continue
function repoLockfileWait {
 repoLockFilePath="${REPODIR}/${REPONAME}.db.tar.gz.lck"
 if ! [ -f "${repoLockFilePath}" ]
 then
   return
 else
   echo "There is a lock file in this repo's directory."
   pid="$(<"${repoLockFilePath}")"

   # If the file contains a pid, check if its alive and wait if it is.
   if [ -z "${pid}" ]
   then
     echo "The file contains no pid. Removing the lock and continuing."
     rm -v "${repoLockFilePath}"
     return
   else
     if ! [[ $pid =~ ^[0-9]+$ ]]
     then
       echo "The pid inside is not a number: ${pid}"
       echo "Removing the lock file and continuing."
       rm -v "${repoLockFilePath}"
       return
     fi
     if [ -d "/proc/${pid}" ]
     then
       echo "Pid ${pid} is running. Waiting for it to exit."
       while [ -d /proc/${pid} ]
       do
         sleep 1
       done
     fi
   fi
 fi
}

#  ____             _
# | __ )  ___  __ _(_)_ __
# |  _ \ / _ \/ _` | | '_ \
# | |_) |  __/ (_| | | | | |
# |____/ \___|\__, |_|_| |_|
#             |___/

while [ $# -gt 0 ]
do
  case "$(tr '[:upper:]' '[:lower:]'<<<$1)" in
    -f|-force|--f|--force)
      echo "Forcing verification of larger packages..."
      force=1
      ;;
    --force-repo-add)
      echo "Forcing repo-add on all packages after signing rounds..."
      repoAddForce=1
      ;;
    -verify|--verify)
      echo "Verifying smaller packages..."
      verify=1
      ;;
    -everything|--everything)
      echo "Forcing all verification and repo package re-adding..."
      everything=1
      force=1
      repoAddForce=1
      verify=1
      ;;
  esac
  shift
done

# Make some assumptions if needed.
[ -z "${REPOBASE}" ] && export REPOBASE=/repo

# Enumerate and sign all repos and their respective packages
find ${REPOBASE} \( -name '*.zst' -or -name '*.xz' \) -printf %h\\n | sort -u | while read REPODIR
do
  echo ""
  REPO_DIR_KEYS=(${REPODIR//// })
  # Assume the repo name is the directory before the architecture directory.
  export REPONAME="${REPO_DIR_KEYS[-2]}"

  echo -e "REPODIR=${REPOBASE}"
  echo -e "REPONAME=${REPONAME}"

  if [ $(find "${REPODIR}" -type f -regextype egrep -iregex ".*/${REPONAME}.(db|files).tar.gz" | wc -l) -eq 0 ]
  then
    echo "Repo doesn't seem to exist. Creating..."
    repoLockfileWait
    repo-add ${REPODIR}/${REPONAME}.db.tar.gz ${files[*]}
  fi

  # Find things in the repodir

  # Sign anything without a .sig file.
  files=$(    find ${REPODIR} -type f -regextype egrep -iregex '.*.pkg.*(db|gz|xz|zst)')
  repoFiles=$(find ${REPODIR} -type f -regextype egrep -iregex ".*/${REPONAME}.(db|files).tar.gz")

  for file in ${files[*]} ${repoFiles[*]}
  do
    if ! [ -f "${file}.sig" ]
    then
      signThing && repoAddThing
    fi

  done

  if [ -n "${verify}" ]
  then
    for file in ${files[*]}
    do
      size=$(stat -c%s "$file")
      if [ $size -le 104857600 ] || [[ -n "${force}" ]] # Do not verify items over 100MB by default.
      then
        if ! verifyThing
        then
          signThing
        fi
      else
        echo "Skipping sig verification of file due to 101MB limit: ${file}"
      fi
    done
  fi

  # Repo-add all package files if --repo-add-force were specified.
  if [ -n "${repoAddForce}" ]
  then
    echo "--force-repo-add specified."
    echo "Calling repo-add on all packages in the directory (${#files[*]})"
    repoLockfileWait
    repo-add --new --sign ${REPODIR}/${REPONAME}.db.tar.gz ${files[*]} || exit 1
  fi
done
